{"version":3,"sources":["Matrix.ts"],"names":["MatrixIndex","isMatrix","obj","__typename__","processTransform","m","transforms","transform","key","Object","keys","value","translate","scale","skew","rotate","toDegrees","exhaustiveCheck","a","Error","rad","Math","PI"],"mappings":";;;;;;IAEYA,W;;;WAAAA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;AAAAA,EAAAA,W,CAAAA,W;GAAAA,W,2BAAAA,W;;AAYL,MAAMC,QAAQ,GAAIC,GAAD,IACtBA,GAAG,KAAK,IAAR,IAAiBA,GAAD,CAA+BC,YAA/B,KAAgD,QAD3D;;;;AA2CA,MAAMC,gBAAgB,GAAG,CAC9BC,CAD8B,EAE9BC,UAF8B,KAG3B;AACH,OAAK,MAAMC,SAAX,IAAwBD,UAAxB,EAAoC;AAClC,UAAME,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAYH,SAAZ,EAAuB,CAAvB,CAAZ;AACA,UAAMI,KAAK,GAAIJ,SAAD,CAAiDC,GAAjD,CAAd;;AACA,QAAIA,GAAG,KAAK,YAAZ,EAA0B;AACxBH,MAAAA,CAAC,CAACO,SAAF,CAAYD,KAAZ,EAAmB,CAAnB;AACA;AACD;;AACD,QAAIH,GAAG,KAAK,YAAZ,EAA0B;AACxBH,MAAAA,CAAC,CAACO,SAAF,CAAY,CAAZ,EAAeD,KAAf;AACA;AACD;;AACD,QAAIH,GAAG,KAAK,OAAZ,EAAqB;AACnBH,MAAAA,CAAC,CAACQ,KAAF,CAAQF,KAAR,EAAeA,KAAf;AACA;AACD;;AACD,QAAIH,GAAG,KAAK,QAAZ,EAAsB;AACpBH,MAAAA,CAAC,CAACQ,KAAF,CAAQF,KAAR,EAAe,CAAf;AACA;AACD;;AACD,QAAIH,GAAG,KAAK,QAAZ,EAAsB;AACpBH,MAAAA,CAAC,CAACQ,KAAF,CAAQ,CAAR,EAAWF,KAAX;AACA;AACD;;AACD,QAAIH,GAAG,KAAK,OAAZ,EAAqB;AACnBH,MAAAA,CAAC,CAACS,IAAF,CAAOH,KAAP,EAAc,CAAd;AACA;AACD;;AACD,QAAIH,GAAG,KAAK,OAAZ,EAAqB;AACnBH,MAAAA,CAAC,CAACS,IAAF,CAAO,CAAP,EAAUH,KAAV;AACA;AACD;;AACD,QAAIH,GAAG,KAAK,QAAR,IAAoBA,GAAG,KAAK,SAAhC,EAA2C;AACzC,UAAIP,QAAQ,CAACI,CAAD,CAAZ,EAAiB;AACfA,QAAAA,CAAC,CAACU,MAAF,CAASJ,KAAT;AACD,OAFD,MAEO;AACLN,QAAAA,CAAC,CAACU,MAAF,CAASC,SAAS,CAACL,KAAD,CAAlB,EAA2B,CAA3B,EAA8B,CAA9B;AACD;;AACD;AACD;;AACDM,IAAAA,eAAe,CAACT,GAAD,CAAf;AACD;;AACD,SAAOH,CAAP;AACD,CA9CM;;;;AAgDP,MAAMY,eAAe,GAAIC,CAAD,IAAqB;AAC3C,QAAM,IAAIC,KAAJ,CAAW,2BAA0BD,CAAE,EAAvC,CAAN;AACD,CAFD;;AAIO,MAAMF,SAAS,GAAII,GAAD,IAAiB;AACxC,SAAQA,GAAG,GAAG,GAAP,GAAcC,IAAI,CAACC,EAA1B;AACD,CAFM","sourcesContent":["import type { SkJSIInstance } from \"./JsiInstance\";\nimport type { SkCanvas } from \"./Canvas\";\nexport enum MatrixIndex {\n  ScaleX = 0,\n  SkewX = 1,\n  TransX = 2,\n  SkewY = 3,\n  ScaleY = 4,\n  TransY = 5,\n  Persp0 = 6,\n  Persp1 = 7,\n  Persp2 = 8,\n}\n\nexport const isMatrix = (obj: unknown): obj is SkMatrix =>\n  obj !== null && (obj as SkJSIInstance<string>).__typename__ === \"Matrix\";\n\nexport interface SkMatrix extends SkJSIInstance<\"Matrix\"> {\n  concat: (matrix: SkMatrix) => void;\n  translate: (x: number, y: number) => void;\n  scale: (x: number, y?: number) => void;\n  skew: (x: number, y: number) => void;\n  rotate: (theta: number) => void;\n  identity: () => void;\n  get: () => number[];\n}\n\ntype Transform2dName =\n  | \"translateX\"\n  | \"translateY\"\n  | \"scale\"\n  | \"skewX\"\n  | \"skewY\"\n  | \"scaleX\"\n  | \"scaleY\"\n  | \"rotateZ\"\n  | \"rotate\";\n\ntype Transformations = {\n  readonly [Name in Transform2dName]: number;\n};\n\nexport type Transforms2d = readonly (\n  | Pick<Transformations, \"translateX\">\n  | Pick<Transformations, \"translateY\">\n  | Pick<Transformations, \"scale\">\n  | Pick<Transformations, \"scaleX\">\n  | Pick<Transformations, \"scaleY\">\n  | Pick<Transformations, \"skewX\">\n  | Pick<Transformations, \"skewY\">\n  | Pick<Transformations, \"rotate\">\n)[];\n\nexport interface TransformProp {\n  transform?: Transforms2d;\n}\n\nexport const processTransform = <T extends SkMatrix | SkCanvas>(\n  m: T,\n  transforms: Transforms2d\n) => {\n  for (const transform of transforms) {\n    const key = Object.keys(transform)[0] as Transform2dName;\n    const value = (transform as Pick<Transformations, typeof key>)[key];\n    if (key === \"translateX\") {\n      m.translate(value, 0);\n      continue;\n    }\n    if (key === \"translateY\") {\n      m.translate(0, value);\n      continue;\n    }\n    if (key === \"scale\") {\n      m.scale(value, value);\n      continue;\n    }\n    if (key === \"scaleX\") {\n      m.scale(value, 1);\n      continue;\n    }\n    if (key === \"scaleY\") {\n      m.scale(1, value);\n      continue;\n    }\n    if (key === \"skewX\") {\n      m.skew(value, 0);\n      continue;\n    }\n    if (key === \"skewY\") {\n      m.skew(0, value);\n      continue;\n    }\n    if (key === \"rotate\" || key === \"rotateZ\") {\n      if (isMatrix(m)) {\n        m.rotate(value);\n      } else {\n        m.rotate(toDegrees(value), 0, 0);\n      }\n      continue;\n    }\n    exhaustiveCheck(key);\n  }\n  return m;\n};\n\nconst exhaustiveCheck = (a: never): never => {\n  throw new Error(`Unknown transformation: ${a}`);\n};\n\nexport const toDegrees = (rad: number) => {\n  return (rad * 180) / Math.PI;\n};\n"]}
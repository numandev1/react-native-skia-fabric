{"version":3,"sources":["interpolatePaths.ts"],"names":["lerp","value","from","to","p1","p2","t","interpolate","interpolatePaths","input","outputRange","options","extrapolation","extrapolateLeft","Extrapolate","CLAMP","EXTEND","IDENTITY","Error","length","extrapolateRight","i"],"mappings":";;;;;;;AACA;;AAGA;;AAEA,MAAMA,IAAI,GAAG,CACXC,KADW,EAEXC,IAFW,EAGXC,EAHW,EAIXC,EAJW,EAKXC,EALW,KAMR;AACH,QAAMC,CAAC,GAAG,CAACL,KAAK,GAAGC,IAAT,KAAkBC,EAAE,GAAGD,IAAvB,CAAV;AACA,SAAOG,EAAE,CAACE,WAAH,CAAeH,EAAf,EAAmBE,CAAnB,CAAP;AACD,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAME,gBAAgB,GAAG,CAC9BP,KAD8B,EAE9BQ,KAF8B,EAG9BC,WAH8B,EAI9BC,OAJ8B,KAK3B;AACH,QAAMC,aAAa,GAAG,+CAA6BD,OAA7B,CAAtB;;AACA,MAAIV,KAAK,GAAGQ,KAAK,CAAC,CAAD,CAAjB,EAAsB;AACpB,YAAQG,aAAa,CAACC,eAAtB;AACE,WAAKC,yBAAYC,KAAjB;AACE,eAAOL,WAAW,CAAC,CAAD,CAAlB;;AACF,WAAKI,yBAAYE,MAAjB;AACE,eAAOhB,IAAI,CAACC,KAAD,EAAQQ,KAAK,CAAC,CAAD,CAAb,EAAkBA,KAAK,CAAC,CAAD,CAAvB,EAA4BC,WAAW,CAAC,CAAD,CAAvC,EAA4CA,WAAW,CAAC,CAAD,CAAvD,CAAX;;AACF,WAAKI,yBAAYG,QAAjB;AACE,cAAM,IAAIC,KAAJ,CACJ,uEADI,CAAN;;AAGF;AACE,wCAAgBN,aAAa,CAACC,eAA9B;AAVJ;AAYD,GAbD,MAaO,IAAIZ,KAAK,GAAGQ,KAAK,CAACA,KAAK,CAACU,MAAN,GAAe,CAAhB,CAAjB,EAAqC;AAC1C,YAAQP,aAAa,CAACQ,gBAAtB;AACE,WAAKN,yBAAYC,KAAjB;AACE,eAAOL,WAAW,CAACA,WAAW,CAACS,MAAZ,GAAqB,CAAtB,CAAlB;;AACF,WAAKL,yBAAYE,MAAjB;AACE,eAAOhB,IAAI,CACTC,KADS,EAETQ,KAAK,CAACA,KAAK,CAACU,MAAN,GAAe,CAAhB,CAFI,EAGTV,KAAK,CAACA,KAAK,CAACU,MAAN,GAAe,CAAhB,CAHI,EAITT,WAAW,CAACD,KAAK,CAACU,MAAN,GAAe,CAAhB,CAJF,EAKTT,WAAW,CAACD,KAAK,CAACU,MAAN,GAAe,CAAhB,CALF,CAAX;;AAOF,WAAKL,yBAAYG,QAAjB;AACE,cAAM,IAAIC,KAAJ,CACJ,uEADI,CAAN;;AAGF;AACE,wCAAgBN,aAAa,CAACQ,gBAA9B;AAhBJ;AAkBD;;AACD,MAAIC,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,IAAIZ,KAAK,CAACU,MAAN,GAAe,CAA3B,EAA8BE,CAAC,EAA/B,EAAmC;AACjC,QAAIpB,KAAK,IAAIQ,KAAK,CAACY,CAAD,CAAd,IAAqBpB,KAAK,IAAIQ,KAAK,CAACY,CAAC,GAAG,CAAL,CAAvC,EAAgD;AAC9C;AACD;AACF;;AACD,SAAOrB,IAAI,CACTC,KADS,EAETQ,KAAK,CAACY,CAAD,CAFI,EAGTZ,KAAK,CAACY,CAAC,GAAG,CAAL,CAHI,EAITX,WAAW,CAACW,CAAD,CAJF,EAKTX,WAAW,CAACW,CAAC,GAAG,CAAL,CALF,CAAX;AAOD,CArDM","sourcesContent":["import type { SkPath } from \"../../skia/types\";\nimport { exhaustiveCheck } from \"../../renderer/typeddash\";\n\nimport type { ExtrapolationType } from \"./interpolate\";\nimport { validateInterpolationOptions, Extrapolate } from \"./interpolate\";\n\nconst lerp = (\n  value: number,\n  from: number,\n  to: number,\n  p1: SkPath,\n  p2: SkPath\n) => {\n  const t = (value - from) / (to - from);\n  return p2.interpolate(p1, t)!;\n};\n\n/**\n * Maps an input value within a range to an output path within a path range.\n * @param value - The input value.\n * @param inputRange - The range of the input value.\n * @param outputRange - The range of the output path.\n * @param options - Extrapolation options\n * @returns The output path.\n * @example <caption>Map a value between 0 and 1 to a path between two paths.</caption>\n * const path1 = new Path();\n * path1.moveTo(0, 0);\n * path1.lineTo(100, 0);\n * const path2 = new Path();\n * path2.moveTo(0, 0);\n * path2.lineTo(0, 100);\n * const path = interpolatePath(0.5, [0, 1], [path1, path2]);\n */\nexport const interpolatePaths = (\n  value: number,\n  input: number[],\n  outputRange: SkPath[],\n  options?: ExtrapolationType\n) => {\n  const extrapolation = validateInterpolationOptions(options);\n  if (value < input[0]) {\n    switch (extrapolation.extrapolateLeft) {\n      case Extrapolate.CLAMP:\n        return outputRange[0];\n      case Extrapolate.EXTEND:\n        return lerp(value, input[0], input[1], outputRange[0], outputRange[1]);\n      case Extrapolate.IDENTITY:\n        throw new Error(\n          \"Identity is not a supported extrapolation type for interpolatePaths()\"\n        );\n      default:\n        exhaustiveCheck(extrapolation.extrapolateLeft);\n    }\n  } else if (value > input[input.length - 1]) {\n    switch (extrapolation.extrapolateRight) {\n      case Extrapolate.CLAMP:\n        return outputRange[outputRange.length - 1];\n      case Extrapolate.EXTEND:\n        return lerp(\n          value,\n          input[input.length - 2],\n          input[input.length - 1],\n          outputRange[input.length - 2],\n          outputRange[input.length - 1]\n        );\n      case Extrapolate.IDENTITY:\n        throw new Error(\n          \"Identity is not a supported extrapolation type for interpolatePaths()\"\n        );\n      default:\n        exhaustiveCheck(extrapolation.extrapolateRight);\n    }\n  }\n  let i = 0;\n  for (; i <= input.length - 1; i++) {\n    if (value >= input[i] && value <= input[i + 1]) {\n      break;\n    }\n  }\n  return lerp(\n    value,\n    input[i],\n    input[i + 1],\n    outputRange[i],\n    outputRange[i + 1]\n  );\n};\n"]}
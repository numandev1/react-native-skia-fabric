{"version":3,"sources":["useTiming.ts"],"names":["useTiming","toOrParams","config","callback","prevCfgRef","resolvedParameters","nextParams","equals","current","value","from","prevAnimationRef","prevParamsRef","animation","undefined","a","b","JSON","stringify"],"mappings":";;;;;;;AAAA;;AAQA;;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,SAAS,GAAG,CACvBC,UADuB,EAEvBC,MAFuB,EAGvBC,QAHuB,KAID;AAAA;;AACtB;AACA;AACA,QAAMC,UAAU,GAAG,oBAAnB;AACA,QAAMC,kBAAkB,GAAG,oBAAQ,MAAM;AACvC,UAAMC,UAAU,GAAG,kCAAkBL,UAAlB,EAA8BC,MAA9B,CAAnB;;AACA,QAAI,CAACK,MAAM,CAACH,UAAU,CAACI,OAAZ,EAAqBF,UAArB,CAAX,EAA6C;AAC3CF,MAAAA,UAAU,CAACI,OAAX,GAAqBF,UAArB;AACD;;AACD,WAAOF,UAAU,CAACI,OAAlB;AACD,GAN0B,EAMxB,CAACN,MAAD,EAASD,UAAT,CANwB,CAA3B,CAJsB,CAYtB;;AACA,QAAMQ,KAAK,GAAG,iDAASJ,kBAAkB,CAACK,IAA5B,yEAAoC,CAApC,CAAd,CAbsB,CAetB;AACA;;AACA,QAAMC,gBAAgB,GAAG,oBAAzB;AACA,QAAMC,aAAa,GAAG,oBAAtB;AACA,QAAMC,SAAS,GAAG,oBAAQ,MAAM;AAC9B,QAAI,CAACN,MAAM,CAACK,aAAa,CAACJ,OAAf,EAAwBH,kBAAxB,CAAX,EAAwD;AACtDO,MAAAA,aAAa,CAACJ,OAAd,GAAwBH,kBAAxB;AACAM,MAAAA,gBAAgB,CAACH,OAAjB,GAA2B,gCACzBH,kBADyB,EAEzBI,KAFyB,EAGzBN,QAHyB,CAA3B;AAKD;;AACD,WAAOQ,gBAAgB,CAACH,OAAxB;AACD,GAViB,EAUf,CAACL,QAAD,EAAWE,kBAAX,EAA+BI,KAA/B,CAVe,CAAlB,CAnBsB,CA+BtB;;AACA,wBAAU,MAAM;AACdA,IAAAA,KAAK,CAACI,SAAN,GAAkBA,SAAlB;AACA,WAAO,MAAOJ,KAAK,CAACI,SAAN,GAAkBC,SAAhC;AACD,GAHD,EAGG,CAACD,SAAD,EAAYJ,KAAZ,CAHH,EAhCsB,CAqCtB;;AACA,SAAOA,KAAP;AACD,CA3CM;;;;AA6CP,MAAMF,MAAM,GAAG,CAASQ,CAAT,EAAgBC,CAAhB,KAA0B;AACvC,SAAOC,IAAI,CAACC,SAAL,CAAeH,CAAf,MAAsBE,IAAI,CAACC,SAAL,CAAeF,CAAf,CAA7B;AACD,CAFD","sourcesContent":["import { useEffect, useMemo, useRef } from \"react\";\n\nimport type { SkiaValue, SkiaAnimation } from \"../../values/types\";\nimport type {\n  AnimationParams,\n  TimingConfig,\n  AnimationCallback,\n} from \"../types\";\nimport { useValue } from \"../../values/hooks/useValue\";\n\nimport { getResolvedParams } from \"./functions\";\nimport { createTiming } from \"./createTiming\";\n\n/**\n * Creats an animation value that will run whenever\n * the animation parameters change. The animation start immediately.\n * @param toOrParams\n * @param config\n * @returns A value that is animated\n */\nexport const useTiming = (\n  toOrParams: number | AnimationParams,\n  config?: TimingConfig,\n  callback?: AnimationCallback\n): SkiaValue<number> => {\n  // Resolve parameters - keep a cached version to avoid\n  // unnecesary re-renders.\n  const prevCfgRef = useRef<ReturnType<typeof getResolvedParams>>();\n  const resolvedParameters = useMemo(() => {\n    const nextParams = getResolvedParams(toOrParams, config);\n    if (!equals(prevCfgRef.current, nextParams)) {\n      prevCfgRef.current = nextParams;\n    }\n    return prevCfgRef.current!;\n  }, [config, toOrParams]);\n\n  // Create value\n  const value = useValue(resolvedParameters.from ?? 0);\n\n  // Create timing animation - keep a cached version to avoid\n  // uneccessary recreation of animations\n  const prevAnimationRef = useRef<SkiaAnimation>();\n  const prevParamsRef = useRef<typeof resolvedParameters>();\n  const animation = useMemo(() => {\n    if (!equals(prevParamsRef.current, resolvedParameters)) {\n      prevParamsRef.current = resolvedParameters;\n      prevAnimationRef.current = createTiming(\n        resolvedParameters,\n        value,\n        callback\n      );\n    }\n    return prevAnimationRef.current!;\n  }, [callback, resolvedParameters, value]);\n\n  // Run animation on the value - and stop it on unmount\n  useEffect(() => {\n    value.animation = animation;\n    return () => (value.animation = undefined);\n  }, [animation, value]);\n\n  // Return the value that is animated\n  return value;\n};\n\nconst equals = <T1, T2>(a: T1, b: T2) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n"]}
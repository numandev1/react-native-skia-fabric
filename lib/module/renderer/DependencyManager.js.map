{"version":3,"sources":["DependencyManager.tsx"],"names":["isSelector","isValue","mapKeys","DependencyManager","constructor","registerValues","Map","unsubscribeNodes","nodes","forEach","n","unsubscribeNode","node","subscriptions","Array","from","values","filter","p","has","si","delete","size","unsubscribe","Error","element","entries","find","_","sub","subscribeNode","props","propSubscriptions","initializePropertySubscriptions","length","ps","subscriptionState","get","value","addListener","v","mutators","m","set","map","mutator","update","unregisterDependantValues","keys","remove","clear","nodePropSubscriptions","key","propvalue","push","setProp","current","selector"],"mappings":"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","sourcesContent":["import type { Node } from \"../dom/types\";\nimport type { SkiaValue } from \"../values\";\n\nimport type { AnimatedProps } from \"./processors\";\nimport { isSelector, isValue } from \"./processors\";\nimport { mapKeys } from \"./typeddash\";\n\ntype Unsubscribe = () => void;\ntype Mutator = (value: unknown) => void;\n\ntype SubscriptionState = {\n  nodes: Map<Node<unknown>, Mutator[]>;\n  unsubscribe: null | Unsubscribe;\n};\n\nexport class DependencyManager {\n  registerValues: (values: Array<SkiaValue<unknown>>) => () => void;\n  subscriptions: Map<SkiaValue<unknown>, SubscriptionState> = new Map();\n  unregisterDependantValues: null | Unsubscribe = null;\n\n  constructor(\n    registerValues: (values: Array<SkiaValue<unknown>>) => () => void\n  ) {\n    this.registerValues = registerValues;\n  }\n\n  unsubscribeNodes(nodes: Node<unknown>[]) {\n    nodes.forEach((n) => this.unsubscribeNode(n));\n  }\n\n  /**\n   * Call to unsubscribe all value listeners from the given node based\n   * on the current list of subscriptions for the node. This function\n   * is typically called when the node is unmounted or when one or more\n   * properties have changed.\n   * @param node Node to unsubscribe value listeners from\n   */\n  unsubscribeNode(node: Node<unknown>) {\n    const subscriptions = Array.from(this.subscriptions.values()).filter((p) =>\n      p.nodes.has(node)\n    );\n\n    if (subscriptions) {\n      subscriptions.forEach((si) => {\n        // Delete node from subscription\n        si.nodes.delete(node);\n\n        // Remove subscription if there are no listeneres left on the value\n        if (si.nodes.size === 0) {\n          // There are no more nodes subscribing to this value, we can call\n          // unsubscribe on it.\n          if (!si.unsubscribe) {\n            throw new Error(\"Failed to unsubscribe to value subscription\");\n          }\n          si.unsubscribe && si.unsubscribe();\n\n          // Remove from subscription states as well\n          const element = Array.from(this.subscriptions.entries()).find(\n            ([_, sub]) => sub === si\n          );\n          if (!element) {\n            throw new Error(\"Failed to find value subscription\");\n          }\n          if (!this.subscriptions.delete(element[0])) {\n            throw new Error(\"Failed to delete value subscription\");\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Adds listeners to the provided values so that the node is notified\n   * when a value changes. This is done in an optimized way so that this\n   * class only needs to listen to the value once and then forwards the\n   * change to the node and its listener. This method is typically called\n   * when the node is mounted and when one or more props on the node changes.\n   * @param node Node to subscribe to value changes for\n   * @param props Node's properties\n   * @param onResolveProp Callback when a property value changes\n   */\n  subscribeNode<P>(node: Node<unknown>, props: AnimatedProps<P>) {\n    // Get mutators from node's properties\n    const propSubscriptions = initializePropertySubscriptions(node, props);\n    if (propSubscriptions.length === 0) {\n      return;\n    }\n\n    // Install all mutators for the node\n    propSubscriptions.forEach((ps) => {\n      // Do we already have a state for this SkiaValue\n      let subscriptionState = this.subscriptions.get(ps.value);\n      if (!subscriptionState) {\n        // Let's create a new subscription state for the skia value\n        subscriptionState = {\n          nodes: new Map(),\n          unsubscribe: null,\n        };\n        // Add single subscription to the new value\n        subscriptionState.unsubscribe = ps.value.addListener((v) => {\n          subscriptionState!.nodes.forEach((mutators) =>\n            mutators.forEach((m) => m(v))\n          );\n        });\n        this.subscriptions.set(ps.value, subscriptionState);\n      }\n      // subscription mutators\n      subscriptionState.nodes.set(\n        node,\n        propSubscriptions\n          .filter((m) => m.value === ps.value)\n          .map((m) => m.mutator)\n      );\n    });\n  }\n\n  /**\n   * Called when the hosting container is mounted or updated. This ensures that we have\n   * a ref to the underlying SkiaView so that we can registers redraw listeners\n   * on values used in the current View automatically.\n   */\n  update() {\n    // Remove any previous registrations\n    if (this.unregisterDependantValues) {\n      this.unregisterDependantValues();\n    }\n\n    // Register redraw requests on the SkiaView for each unique value\n    this.unregisterDependantValues = this.registerValues(\n      Array.from(this.subscriptions.keys())\n    );\n  }\n\n  /**\n   * Called when the hosting container is unmounted or recreated. This ensures that we remove\n   * all subscriptions to Skia values so that we don't have any listeners left after\n   * the component is removed.\n   */\n  remove() {\n    // 1) Unregister redraw requests\n    if (this.unregisterDependantValues) {\n      this.unregisterDependantValues();\n      this.unregisterDependantValues = null;\n    }\n\n    // 2) Unregister nodes\n    Array.from(this.subscriptions.values()).forEach((si) => {\n      Array.from(si.nodes.keys()).forEach((node) => this.unsubscribeNode(node));\n    });\n\n    // 3) Clear the rest of the subscriptions\n    this.subscriptions.clear();\n  }\n}\n\nconst initializePropertySubscriptions = <P,>(\n  node: Node<P>,\n  props: AnimatedProps<P>\n) => {\n  const nodePropSubscriptions: Array<{\n    value: SkiaValue<unknown>;\n    mutator: Mutator;\n  }> = [];\n\n  mapKeys(props).forEach((key) => {\n    if (key === \"children\") {\n      return;\n    }\n    const propvalue = props[key];\n\n    if (isValue(propvalue)) {\n      // Subscribe to changes\n      nodePropSubscriptions.push({\n        value: propvalue,\n        mutator: (v) => {\n          node.setProp(key, v as P[typeof key]);\n        },\n      });\n      // Set initial value\n      node.setProp(key, (propvalue as SkiaValue<P[typeof key]>).current);\n    } else if (isSelector(propvalue)) {\n      // Subscribe to changes\n      nodePropSubscriptions.push({\n        value: propvalue.value,\n        mutator: (v) => {\n          node.setProp(key, propvalue.selector(v) as P[typeof key]);\n        },\n      });\n      // Set initial value\n      node.setProp(\n        key,\n        propvalue.selector(propvalue.value.current) as P[typeof key]\n      );\n    } else {\n      // Set initial value\n      node.setProp(key, propvalue as P[typeof key]);\n    }\n  });\n\n  return nodePropSubscriptions;\n};\n"]}
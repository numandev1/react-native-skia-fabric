{"version":3,"sources":["useTiming.ts"],"names":["useEffect","useMemo","useRef","useValue","getResolvedParams","createTiming","useTiming","toOrParams","config","callback","prevCfgRef","resolvedParameters","nextParams","equals","current","value","from","prevAnimationRef","prevParamsRef","animation","undefined","a","b","JSON","stringify"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,OAApB,EAA6BC,MAA7B,QAA2C,OAA3C;AAQA,SAASC,QAAT,QAAyB,6BAAzB;AAEA,SAASC,iBAAT,QAAkC,aAAlC;AACA,SAASC,YAAT,QAA6B,gBAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,SAAS,GAAG,CACvBC,UADuB,EAEvBC,MAFuB,EAGvBC,QAHuB,KAID;AAAA;;AACtB;AACA;AACA,QAAMC,UAAU,GAAGR,MAAM,EAAzB;AACA,QAAMS,kBAAkB,GAAGV,OAAO,CAAC,MAAM;AACvC,UAAMW,UAAU,GAAGR,iBAAiB,CAACG,UAAD,EAAaC,MAAb,CAApC;;AACA,QAAI,CAACK,MAAM,CAACH,UAAU,CAACI,OAAZ,EAAqBF,UAArB,CAAX,EAA6C;AAC3CF,MAAAA,UAAU,CAACI,OAAX,GAAqBF,UAArB;AACD;;AACD,WAAOF,UAAU,CAACI,OAAlB;AACD,GANiC,EAM/B,CAACN,MAAD,EAASD,UAAT,CAN+B,CAAlC,CAJsB,CAYtB;;AACA,QAAMQ,KAAK,GAAGZ,QAAQ,0BAACQ,kBAAkB,CAACK,IAApB,yEAA4B,CAA5B,CAAtB,CAbsB,CAetB;AACA;;AACA,QAAMC,gBAAgB,GAAGf,MAAM,EAA/B;AACA,QAAMgB,aAAa,GAAGhB,MAAM,EAA5B;AACA,QAAMiB,SAAS,GAAGlB,OAAO,CAAC,MAAM;AAC9B,QAAI,CAACY,MAAM,CAACK,aAAa,CAACJ,OAAf,EAAwBH,kBAAxB,CAAX,EAAwD;AACtDO,MAAAA,aAAa,CAACJ,OAAd,GAAwBH,kBAAxB;AACAM,MAAAA,gBAAgB,CAACH,OAAjB,GAA2BT,YAAY,CACrCM,kBADqC,EAErCI,KAFqC,EAGrCN,QAHqC,CAAvC;AAKD;;AACD,WAAOQ,gBAAgB,CAACH,OAAxB;AACD,GAVwB,EAUtB,CAACL,QAAD,EAAWE,kBAAX,EAA+BI,KAA/B,CAVsB,CAAzB,CAnBsB,CA+BtB;;AACAf,EAAAA,SAAS,CAAC,MAAM;AACde,IAAAA,KAAK,CAACI,SAAN,GAAkBA,SAAlB;AACA,WAAO,MAAOJ,KAAK,CAACI,SAAN,GAAkBC,SAAhC;AACD,GAHQ,EAGN,CAACD,SAAD,EAAYJ,KAAZ,CAHM,CAAT,CAhCsB,CAqCtB;;AACA,SAAOA,KAAP;AACD,CA3CM;;AA6CP,MAAMF,MAAM,GAAG,CAASQ,CAAT,EAAgBC,CAAhB,KAA0B;AACvC,SAAOC,IAAI,CAACC,SAAL,CAAeH,CAAf,MAAsBE,IAAI,CAACC,SAAL,CAAeF,CAAf,CAA7B;AACD,CAFD","sourcesContent":["import { useEffect, useMemo, useRef } from \"react\";\n\nimport type { SkiaValue, SkiaAnimation } from \"../../values/types\";\nimport type {\n  AnimationParams,\n  TimingConfig,\n  AnimationCallback,\n} from \"../types\";\nimport { useValue } from \"../../values/hooks/useValue\";\n\nimport { getResolvedParams } from \"./functions\";\nimport { createTiming } from \"./createTiming\";\n\n/**\n * Creats an animation value that will run whenever\n * the animation parameters change. The animation start immediately.\n * @param toOrParams\n * @param config\n * @returns A value that is animated\n */\nexport const useTiming = (\n  toOrParams: number | AnimationParams,\n  config?: TimingConfig,\n  callback?: AnimationCallback\n): SkiaValue<number> => {\n  // Resolve parameters - keep a cached version to avoid\n  // unnecesary re-renders.\n  const prevCfgRef = useRef<ReturnType<typeof getResolvedParams>>();\n  const resolvedParameters = useMemo(() => {\n    const nextParams = getResolvedParams(toOrParams, config);\n    if (!equals(prevCfgRef.current, nextParams)) {\n      prevCfgRef.current = nextParams;\n    }\n    return prevCfgRef.current!;\n  }, [config, toOrParams]);\n\n  // Create value\n  const value = useValue(resolvedParameters.from ?? 0);\n\n  // Create timing animation - keep a cached version to avoid\n  // uneccessary recreation of animations\n  const prevAnimationRef = useRef<SkiaAnimation>();\n  const prevParamsRef = useRef<typeof resolvedParameters>();\n  const animation = useMemo(() => {\n    if (!equals(prevParamsRef.current, resolvedParameters)) {\n      prevParamsRef.current = resolvedParameters;\n      prevAnimationRef.current = createTiming(\n        resolvedParameters,\n        value,\n        callback\n      );\n    }\n    return prevAnimationRef.current!;\n  }, [callback, resolvedParameters, value]);\n\n  // Run animation on the value - and stop it on unmount\n  useEffect(() => {\n    value.animation = animation;\n    return () => (value.animation = undefined);\n  }, [animation, value]);\n\n  // Return the value that is animated\n  return value;\n};\n\nconst equals = <T1, T2>(a: T1, b: T2) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n"]}
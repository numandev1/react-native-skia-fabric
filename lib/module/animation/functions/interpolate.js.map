{"version":3,"sources":["interpolate.ts"],"names":["Extrapolate","getVal","type","coef","val","leftEdgeOutput","rightEdgeOutput","x","IDENTITY","CLAMP","EXTEND","isExtrapolate","value","validateInterpolationOptions","extrapolationConfig","extrapolateLeft","extrapolateRight","Error","Object","assign","internalInterpolate","narrowedInput","leftEdgeInput","rightEdgeInput","progress","interpolate","input","output","length","i"],"mappings":"AAAA;AACA,WAAYA,WAAZ;;WAAYA,W;AAAAA,EAAAA,W;AAAAA,EAAAA,W;AAAAA,EAAAA,W;GAAAA,W,KAAAA,W;;AA6BZ,SAASC,MAAT,CACEC,IADF,EAEEC,IAFF,EAGEC,GAHF,EAIEC,cAJF,EAKEC,eALF,EAMEC,CANF,EAOU;AACR,UAAQL,IAAR;AACE,SAAKF,WAAW,CAACQ,QAAjB;AACE,aAAOD,CAAP;;AACF,SAAKP,WAAW,CAACS,KAAjB;AACE,UAAIN,IAAI,GAAGC,GAAP,GAAaD,IAAI,GAAGE,cAAxB,EAAwC;AACtC,eAAOA,cAAP;AACD;;AACD,aAAOC,eAAP;;AACF,SAAKN,WAAW,CAACU,MAAjB;AACA;AACE,aAAON,GAAP;AAVJ;AAYD;;AAED,SAASO,aAAT,CAAuBC,KAAvB,EAA4D;AAC1D,SACEA,KAAK,KAAKZ,WAAW,CAACU,MAAtB,IACAE,KAAK,KAAKZ,WAAW,CAACS,KADtB,IAEAG,KAAK,KAAKZ,WAAW,CAACQ,QAHxB;AAKD,C,CAED;AACA;;;AACA,OAAO,SAASK,4BAAT,CACLX,IADK,EAEwB;AAC7B;AACA,QAAMY,mBAAgD,GAAG;AACvDC,IAAAA,eAAe,EAAEf,WAAW,CAACU,MAD0B;AAEvDM,IAAAA,gBAAgB,EAAEhB,WAAW,CAACU;AAFyB,GAAzD;;AAKA,MAAI,CAACR,IAAL,EAAW;AACT,WAAOY,mBAAP;AACD;;AAED,MAAI,OAAOZ,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAI,CAACS,aAAa,CAACT,IAAD,CAAlB,EAA0B;AACxB,YAAM,IAAIe,KAAJ,CACH;AACT,iEAFY,CAAN;AAID;;AACDH,IAAAA,mBAAmB,CAACC,eAApB,GAAsCb,IAAtC;AACAY,IAAAA,mBAAmB,CAACE,gBAApB,GAAuCd,IAAvC;AACA,WAAOY,mBAAP;AACD,GArB4B,CAuB7B;;;AACA,MACGZ,IAAI,CAACa,eAAL,IAAwB,CAACJ,aAAa,CAACT,IAAI,CAACa,eAAN,CAAvC,IACCb,IAAI,CAACc,gBAAL,IAAyB,CAACL,aAAa,CAACT,IAAI,CAACc,gBAAN,CAF1C,EAGE;AACA,UAAM,IAAIC,KAAJ,CACH;AACP;AACA;AACA;AACA,UALU,CAAN;AAOD;;AAEDC,EAAAA,MAAM,CAACC,MAAP,CAAcL,mBAAd,EAAmCZ,IAAnC;AACA,SAAOY,mBAAP;AACD;;AAED,SAASM,mBAAT,CACEb,CADF,EAEEc,aAFF,EAGEP,mBAHF,EAIE;AACA,QAAM;AAAEQ,IAAAA,aAAF;AAAiBC,IAAAA,cAAjB;AAAiClB,IAAAA,cAAjC;AAAiDC,IAAAA;AAAjD,MACJe,aADF;;AAEA,MAAIE,cAAc,GAAGD,aAAjB,KAAmC,CAAvC,EAA0C;AACxC,WAAOjB,cAAP;AACD;;AACD,QAAMmB,QAAQ,GAAG,CAACjB,CAAC,GAAGe,aAAL,KAAuBC,cAAc,GAAGD,aAAxC,CAAjB;AACA,QAAMlB,GAAG,GAAGC,cAAc,GAAGmB,QAAQ,IAAIlB,eAAe,GAAGD,cAAtB,CAArC;AACA,QAAMF,IAAI,GAAGG,eAAe,IAAID,cAAnB,GAAoC,CAApC,GAAwC,CAAC,CAAtD;;AAEA,MAAIF,IAAI,GAAGC,GAAP,GAAaD,IAAI,GAAGE,cAAxB,EAAwC;AACtC,WAAOJ,MAAM,CACXa,mBAAmB,CAACC,eADT,EAEXZ,IAFW,EAGXC,GAHW,EAIXC,cAJW,EAKXC,eALW,EAMXC,CANW,CAAb;AAQD,GATD,MASO,IAAIJ,IAAI,GAAGC,GAAP,GAAaD,IAAI,GAAGG,eAAxB,EAAyC;AAC9C,WAAOL,MAAM,CACXa,mBAAmB,CAACE,gBADT,EAEXb,IAFW,EAGXC,GAHW,EAIXC,cAJW,EAKXC,eALW,EAMXC,CANW,CAAb;AAQD;;AAED,SAAOH,GAAP;AACD,C,CAED;;;AACA,OAAO,SAASqB,WAAT,CACLlB,CADK,EAELmB,KAFK,EAGLC,MAHK,EAILzB,IAJK,EAKG;AACR,MAAIwB,KAAK,CAACE,MAAN,GAAe,CAAf,IAAoBD,MAAM,CAACC,MAAP,GAAgB,CAAxC,EAA2C;AACzC,UAAMX,KAAK,CACT,oEADS,CAAX;AAGD;;AAED,QAAMH,mBAAmB,GAAGD,4BAA4B,CAACX,IAAD,CAAxD;AACA,QAAM;AAAE0B,IAAAA;AAAF,MAAaF,KAAnB;AACA,QAAML,aAAyC,GAAG;AAChDC,IAAAA,aAAa,EAAEI,KAAK,CAAC,CAAD,CAD4B;AAEhDH,IAAAA,cAAc,EAAEG,KAAK,CAAC,CAAD,CAF2B;AAGhDrB,IAAAA,cAAc,EAAEsB,MAAM,CAAC,CAAD,CAH0B;AAIhDrB,IAAAA,eAAe,EAAEqB,MAAM,CAAC,CAAD;AAJyB,GAAlD;;AAMA,MAAIC,MAAM,GAAG,CAAb,EAAgB;AACd,QAAIrB,CAAC,GAAGmB,KAAK,CAACE,MAAM,GAAG,CAAV,CAAb,EAA2B;AACzBP,MAAAA,aAAa,CAACC,aAAd,GAA8BI,KAAK,CAACE,MAAM,GAAG,CAAV,CAAnC;AACAP,MAAAA,aAAa,CAACE,cAAd,GAA+BG,KAAK,CAACE,MAAM,GAAG,CAAV,CAApC;AACAP,MAAAA,aAAa,CAAChB,cAAd,GAA+BsB,MAAM,CAACC,MAAM,GAAG,CAAV,CAArC;AACAP,MAAAA,aAAa,CAACf,eAAd,GAAgCqB,MAAM,CAACC,MAAM,GAAG,CAAV,CAAtC;AACD,KALD,MAKO;AACL,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B,YAAItB,CAAC,IAAImB,KAAK,CAACG,CAAD,CAAd,EAAmB;AACjBR,UAAAA,aAAa,CAACC,aAAd,GAA8BI,KAAK,CAACG,CAAC,GAAG,CAAL,CAAnC;AACAR,UAAAA,aAAa,CAACE,cAAd,GAA+BG,KAAK,CAACG,CAAD,CAApC;AACAR,UAAAA,aAAa,CAAChB,cAAd,GAA+BsB,MAAM,CAACE,CAAC,GAAG,CAAL,CAArC;AACAR,UAAAA,aAAa,CAACf,eAAd,GAAgCqB,MAAM,CAACE,CAAD,CAAtC;AACA;AACD;AACF;AACF;AACF;;AAED,SAAOT,mBAAmB,CAACb,CAAD,EAAIc,aAAJ,EAAmBP,mBAAnB,CAA1B;AACD","sourcesContent":["/* eslint-disable max-len */\nexport enum Extrapolate {\n  IDENTITY = \"identity\",\n  CLAMP = \"clamp\",\n  EXTEND = \"extend\",\n}\n\ninterface InterpolationNarrowedInput {\n  leftEdgeInput: number;\n  rightEdgeInput: number;\n  leftEdgeOutput: number;\n  rightEdgeOutput: number;\n}\n\nexport interface ExtrapolationConfig {\n  extrapolateLeft?: Extrapolate | string;\n  extrapolateRight?: Extrapolate | string;\n}\n\ninterface RequiredExtrapolationConfig {\n  extrapolateLeft: Extrapolate;\n  extrapolateRight: Extrapolate;\n}\n\nexport type ExtrapolationType =\n  | ExtrapolationConfig\n  | Extrapolate\n  | string\n  | undefined;\n\nfunction getVal(\n  type: Extrapolate,\n  coef: number,\n  val: number,\n  leftEdgeOutput: number,\n  rightEdgeOutput: number,\n  x: number\n): number {\n  switch (type) {\n    case Extrapolate.IDENTITY:\n      return x;\n    case Extrapolate.CLAMP:\n      if (coef * val < coef * leftEdgeOutput) {\n        return leftEdgeOutput;\n      }\n      return rightEdgeOutput;\n    case Extrapolate.EXTEND:\n    default:\n      return val;\n  }\n}\n\nfunction isExtrapolate(value: string): value is Extrapolate {\n  return (\n    value === Extrapolate.EXTEND ||\n    value === Extrapolate.CLAMP ||\n    value === Extrapolate.IDENTITY\n  );\n}\n\n// validates extrapolations type\n// if type is correct, converts it to ExtrapolationConfig\nexport function validateInterpolationOptions(\n  type: ExtrapolationType\n): RequiredExtrapolationConfig {\n  // initialize extrapolationConfig with default extrapolation\n  const extrapolationConfig: RequiredExtrapolationConfig = {\n    extrapolateLeft: Extrapolate.EXTEND,\n    extrapolateRight: Extrapolate.EXTEND,\n  };\n\n  if (!type) {\n    return extrapolationConfig;\n  }\n\n  if (typeof type === \"string\") {\n    if (!isExtrapolate(type)) {\n      throw new Error(\n        `No supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n        interpolate(value, [inputRange], [outputRange], \"clamp\")`\n      );\n    }\n    extrapolationConfig.extrapolateLeft = type;\n    extrapolationConfig.extrapolateRight = type;\n    return extrapolationConfig;\n  }\n\n  // otherwise type is extrapolation config object\n  if (\n    (type.extrapolateLeft && !isExtrapolate(type.extrapolateLeft)) ||\n    (type.extrapolateRight && !isExtrapolate(type.extrapolateRight))\n  ) {\n    throw new Error(\n      `No supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n      interpolate(value, [inputRange], [outputRange], {\n        extrapolateLeft: Extrapolation.CLAMP,\n        extrapolateRight: Extrapolation.IDENTITY\n      }})`\n    );\n  }\n\n  Object.assign(extrapolationConfig, type);\n  return extrapolationConfig;\n}\n\nfunction internalInterpolate(\n  x: number,\n  narrowedInput: InterpolationNarrowedInput,\n  extrapolationConfig: RequiredExtrapolationConfig\n) {\n  const { leftEdgeInput, rightEdgeInput, leftEdgeOutput, rightEdgeOutput } =\n    narrowedInput;\n  if (rightEdgeInput - leftEdgeInput === 0) {\n    return leftEdgeOutput;\n  }\n  const progress = (x - leftEdgeInput) / (rightEdgeInput - leftEdgeInput);\n  const val = leftEdgeOutput + progress * (rightEdgeOutput - leftEdgeOutput);\n  const coef = rightEdgeOutput >= leftEdgeOutput ? 1 : -1;\n\n  if (coef * val < coef * leftEdgeOutput) {\n    return getVal(\n      extrapolationConfig.extrapolateLeft,\n      coef,\n      val,\n      leftEdgeOutput,\n      rightEdgeOutput,\n      x\n    );\n  } else if (coef * val > coef * rightEdgeOutput) {\n    return getVal(\n      extrapolationConfig.extrapolateRight,\n      coef,\n      val,\n      leftEdgeOutput,\n      rightEdgeOutput,\n      x\n    );\n  }\n\n  return val;\n}\n\n// e.g. function interpolate(x, input, output, type = Extrapolatation.CLAMP)\nexport function interpolate(\n  x: number,\n  input: readonly number[],\n  output: readonly number[],\n  type?: ExtrapolationType\n): number {\n  if (input.length < 2 || output.length < 2) {\n    throw Error(\n      \"Interpolation input and output should contain at least two values.\"\n    );\n  }\n\n  const extrapolationConfig = validateInterpolationOptions(type);\n  const { length } = input;\n  const narrowedInput: InterpolationNarrowedInput = {\n    leftEdgeInput: input[0],\n    rightEdgeInput: input[1],\n    leftEdgeOutput: output[0],\n    rightEdgeOutput: output[1],\n  };\n  if (length > 2) {\n    if (x > input[length - 1]) {\n      narrowedInput.leftEdgeInput = input[length - 2];\n      narrowedInput.rightEdgeInput = input[length - 1];\n      narrowedInput.leftEdgeOutput = output[length - 2];\n      narrowedInput.rightEdgeOutput = output[length - 1];\n    } else {\n      for (let i = 1; i < length; ++i) {\n        if (x <= input[i]) {\n          narrowedInput.leftEdgeInput = input[i - 1];\n          narrowedInput.rightEdgeInput = input[i];\n          narrowedInput.leftEdgeOutput = output[i - 1];\n          narrowedInput.rightEdgeOutput = output[i];\n          break;\n        }\n      }\n    }\n  }\n\n  return internalInterpolate(x, narrowedInput, extrapolationConfig);\n}\n"]}